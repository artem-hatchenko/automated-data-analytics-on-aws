/*! Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
SPDX-License-Identifier: Apache-2.0 */
import { Construct } from 'constructs';
import { OperationalMetricsConfig } from '@ada/infra-common';
import DataIngressGateway from '@ada/services/data-product/core/network/transit-gateway';
import DataIngressVPC from '@ada/services/data-product/core/network/vpc';
import type * as constructs from 'constructs';
import type { ArnComponents, StackProps as BaseStackProps, Stack } from 'aws-cdk-lib';
import type { AthenaQueryExecutorStateMachine } from '@ada/services/query/components/athena-query-executor-step-function';
import type { Bucket, IBucket } from 'aws-cdk-lib/aws-s3';
import type { CallingUser } from '@ada/common';
import type { Class } from 'type-fest';
import type { Connectors } from '@ada/connectors';
import type { CrawlerPollerStateMachine } from '@ada/services/data-product/components/crawler-poller-state-machine';
import type { DataProductCreationStateMachine } from '@ada/services/data-product/components/creation-state-machine';
import type { DataProductEntity } from '@ada/api';
import type { DataProductInfraLambdas } from '@ada/dynamic-infra/lambdas';
import type { Database, IDatabase } from '@aws-cdk/aws-glue-alpha';
import type { IFunction } from 'aws-cdk-lib/aws-lambda';
import type { IKey, Key } from 'aws-cdk-lib/aws-kms';
import type { INotificationBus } from '@ada/services/api/components/notification/constructs/bus';
import type { IRole } from 'aws-cdk-lib/aws-iam';
import type { IStateMachine } from 'aws-cdk-lib/aws-stepfunctions';
import type { ITable, Table } from 'aws-cdk-lib/aws-dynamodb';
import type { IngressContainerInfra } from '@ada/services/data-product/container/infra';
import type { MicroserviceApi, MicroserviceProps } from '@ada/microservice-common';
import type { StringParameter } from 'aws-cdk-lib/aws-ssm';

// NB: Ensure that all above imports are `type` only! Do not import implementations
/* eslint-disable @typescript-eslint/no-namespace */
export namespace StaticInfra {
  /**
   * Lambda function arns that may be referenced by the dynamic data product infrastructure
   */
  export interface Lambdas {
    validateS3PathLambdaArn: string;
    getCrawledTableDetailsArn: string;
    prepareTransformChainArn: string;
    prepareNextTransformArn: string;
    athenaUtilitiesLambdaName: string;
    generatePIIQueryLambdaArn: string;
    getPiiQueryResultLambdaArn: string;
    prepareExternalImportLambdaArn: string;
    startDataImportLambdaArn: string;
  }

  export interface IDataIngressVPC {
    subnetIds: string[];
    availabilityZones: string[];
    securityGroupIds: string[];
  }

  /**
   * Base `IStatckParams` that the base stack defines before any connectors are applied.
   */
  export interface IStaticParamsBase {
    /** The globally unique hash generated by core stack deployment for explicit naming */
    readonly globalHash: string;

    readonly counterTableName: string;
    readonly glueDatabaseArn: string;
    readonly glueKmsKeyArn: string;
    readonly glueSecurityConfigurationName: string;
    readonly eventBusName: string;
    readonly glueCrawlerStateMachineName: string;
    readonly scriptBucketName: string;
    readonly dataBucketName: string;
    readonly lambdas: Lambdas;
    readonly executeAthenaQueryLambdaRoleArn: string;
    readonly executeGeneratedQueryStateMachineArn: string;
    readonly dataIngressVPC: IDataIngressVPC;
  }

  /**
   * References to static infrastructure for use in the dynamic data product infrastructure that
   * get stored in SSM Parameter to later be dereferenced based on IStaticRefs
   * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces
   */
  export type IStaticParams = IStaticParamsBase & Connectors.Infra.Static.PARAMS;

  export namespace Stack {
    export interface IConstructProps extends MicroserviceProps {
      glueKmsKey: Key;
      executeAthenaQueryLambdaRoleArn: string;
      governanceApi: MicroserviceApi;
      ontologyApi: MicroserviceApi;
      queryParseRenderApi: MicroserviceApi;
      cachedQueryTable: Table;
      athenaOutputBucket: Bucket;
      accessLogsBucket: Bucket;
      operationalMetricsConfig: OperationalMetricsConfig;
    }

    export interface IBaseConstruct extends constructs.IConstruct {
      readonly glueKmsKey: Key;
      readonly executeGeneratedQueryStateMachine: AthenaQueryExecutorStateMachine;
      readonly crawlerPollerStateMachine: CrawlerPollerStateMachine;
      readonly dataProductCreationStateMachine: DataProductCreationStateMachine;
      readonly database: Database;
      readonly dataBucket: Bucket;
      readonly scriptBucket: Bucket;
      readonly glueSecurityConfigurationName: string;
      readonly dataProductInfraLambdas: DataProductInfraLambdas;
      readonly lastUpdatedDetailTable: Table;

      readonly dataIngressVPC: DataIngressVPC;
      readonly ingressContainerInfra: IngressContainerInfra;
      readonly dataIngressGateway: DataIngressGateway;

      readonly staticInfraParameter: StringParameter;
      // initially "base", but connectors will modify
      readonly staticInfraParameterValue: StaticInfra.IStaticParamsBase;
    }

    /**
     * Defines the properties exposed by the StaticInfrastructureStack, which
     * is modified by connectors using typescript interface merging.
     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces
     */
    export type IConstruct = IBaseConstruct & {
      readonly staticInfraParameterValue: Connectors.Infra.Static.PARAMS;
    };

    export type IConstructParameters = [scope: constructs.Construct, id: string, props: IConstructProps];

    export type IBaseConstructConstructor = new (...args: IConstructParameters) => IBaseConstruct;
    export type IBaseConstructClass = Class<IBaseConstruct, IConstructParameters>;

    export type IConstructConstructor = new (...args: IConstructParameters) => IConstruct;
    export type IConstructClass = Class<IConstruct, IConstructParameters>;
  }

  export namespace Refs {
    /**
     * Base static refs that are defined by the base stack, before connectors are applied.
     */
    export interface IBaseRecord {
      readonly counterTable: ITable;
      readonly notificationBus: INotificationBus;
      readonly glueDBArn: ArnComponents;
      readonly glueKmsKey: IKey;
      readonly glueDatabase: IDatabase;
      readonly scriptBucket: IBucket;
      readonly dataBucket: IBucket;
      readonly executeAthenaQueryLambdaRole: IRole;
      readonly crawlerStateMachine: IStateMachine;
      readonly executeGeneratedQueryStateMachine: IStateMachine;
      readonly getCrawledTableDetailsLambda: IFunction;
      readonly prepareTransformChainLambda: IFunction;
      readonly prepareNextTransformLambda: IFunction;
      readonly validateS3PathLambda: IFunction;
      readonly athenaUtilitiesLambdaName: string;
      readonly generatePIIQueryLambda: IFunction;
      readonly getPiiQueryResultLambda: IFunction;
      readonly prepareExternalImportLambda: IFunction;
      readonly startDataImportLambda: IFunction;
      readonly glueSecurityConfigurationName: string;
      readonly dataIngressVPC: IDataIngressVPC;
    }

    /**
     * Defines the dereferenced infra mapped from `IStaticParams` which is the
     * SSM Parameter that static infra stores parameter mapping in.
     */
    export type IRecord = IBaseRecord & Connectors.Infra.Static.REFS;

    export interface IConstructProps {
      staticInfrastructure: IStaticParams;
    }

    export interface IBaseConstruct extends constructs.IConstruct {
      readonly staticInfrastructureReferences: IBaseRecord;
    }
    export interface IConstruct extends IBaseConstruct {
      readonly staticInfrastructureReferences: IRecord;
    }

    export type IConstructParameters = [scope: constructs.Construct, id: string, props: IConstructProps];

    export type IBaseConstructConstructor = new (...args: IConstructParameters) => IBaseConstruct;
    export type IBaseConstructClass = Class<IBaseConstruct, IConstructParameters>;

    export type IConstructConstructor = new (...args: IConstructParameters) => IConstruct;
    export type IConstructClass = Class<IConstruct, IConstructParameters>;
  }
}

export namespace DynamicInfra {
  export interface StackProps extends BaseStackProps {
    readonly dataProduct: DataProductEntity;
    readonly callingUser: CallingUser;
    readonly staticInfrastructure: StaticInfra.IStaticParams;
    readonly additionalNotificationPayload?: { [key: string]: any };
    readonly extraJobArgs?: { [key: string]: string };
  }

  export interface IStack extends Stack {
    readonly staticInfrastructureReferences: StaticInfra.Refs.IRecord;
    readonly dataProductUniqueIdentifier: string;
    readonly dataBucketPath: string;

    readonly stackIdentifier: string;
  }
  export interface StackClass {
    new (scope: Construct, id: string, props: StackProps): IStack;
  }
}
